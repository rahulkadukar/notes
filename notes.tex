% This file contains notes that I made when I was learning programming languages
\documentclass[11pt,a4paper,oneside]{book}
\usepackage[T1]{fontenc}
\usepackage[margin=1in]{geometry}
\usepackage{listings,caption,color,multicol,textcomp,tabularx,longtable}
\usepackage{tikz}
\usetikzlibrary{shapes.geometric, arrows}

\tikzstyle{startstop} = [
  rectangle,
  rounded corners,
  minimum width=3cm,
  minimum height=0.75cm,
  text centered, 
  draw=black,
  fill=red!30 ]
\tikzstyle{io} = [
  trapezium,
  trapezium left angle=70,
  trapezium right angle=110,
  minimum width=3cm, 
  minimum height=0.75cm,
  text centered,
  draw=black,
  fill=blue!30 ]
\tikzstyle{process} = [
  rectangle,
  minimum width=3cm,
  minimum height=0.75cm,
  text centered,
  draw=black, 
  fill=orange!30 ]
\tikzstyle{decision} = [
  diamond,
  minimum width=3cm,
  minimum height=0.75cm,
  text centered,
  draw=black, 
  fill=green!30 ]
\tikzstyle{arrow} = [
  thick,
  ->,
  >=stealth ]

\setcounter{tocdepth}{1}

\definecolor{keyword}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{text}{RGB}{52, 152, 219}
\definecolor{comment}{rgb}{0.58,0,0.82}
\definecolor{string}{RGB}{255,127,0}
\definecolor{caption}{RGB}{188,232,241}
\definecolor{captionText}{RGB}{49,112,143}

\lstset{
  frame=single,
  framexleftmargin=-5.9pt,
  framexrightmargin=2.6pt,
  language=C,
  rulecolor=\color{caption},
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  keywordstyle=\color{keyword},
  commentstyle=\itshape\color{comment},
  identifierstyle=\color{text},
  stringstyle=\color{string},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\DeclareCaptionFont{white}{\color{captionText}}
\DeclareCaptionFormat{listing}{
  \colorbox{caption}
  {\parbox
    {\dimexpr\textwidth-2\fboxsep\relax}
    {#1#2#3}
  }
}

\captionsetup[lstlisting]{format=listing,labelfont=white,textfont=white}


% This section contains general information about the author
\begin{document}
\title{My Reference Book}
\author{
Rahul Kadukar, \\
North Bergen, New Jersey, \\
USA 07047 \\
\\
\texttt{\textcolor{blue}{rahul.kadukar@rutgers.edu}} \\
\texttt{\textcolor{blue}{kadukar.rahul@gmail.com}}
}
\date{\today}
\maketitle
\begingroup
\let\cleardoublepage\clearpage
\tableofcontents
% This can be added to show listings \lstlistoflistings%
\endgroup

% The programming language C starts here
\part{C}
\chapter{An Introduction}
The reference book that I am using is the 6th edition of \textbf{C Primer Plus}
by \textit{\textbf {Stephen Prata}}.
\section{Hello world}
Hello world program in C.
\begin{lstlisting}[title=Hello world program, language=C]
  
  /* This is the Hello world program */
  // This is a single line comment

  #include <stdio.h>
  
  int main(){
    int x;
    x = 42;  
    
    printf("Hello world\n");
    printf("I like the number %d\n", x);
    
    return 0;
  }
  
\end{lstlisting}

\noindent The important things to observe in this program are
\begin{itemize}
  \itemsep-3pt
  \item The first function that is called in a C program is main().
  \item The effect of \#include is the same as typing the contents of that file.
  \item The \#include is called a \textbf{C preprocessor directive}.
  \item The line int x is called \textbf{statement declaration}.
  \item The line x = 42 is called \textbf{assignment statement}.
  \item The \textbf{printf} statement is a function call which passes some arguments.
  \item The \textbf{return} statement is used to indicate end of function execution.
\end{itemize}

\chapter{Keywords}
\section{Keywords and Reserved Identifiers}
There are certain words which cannot be used to name variables in C as these
have a meaning in the C language and these are called \textbf{Keywords} in C.
As a simple rule we should not use a keyword as the name of a variable as it
will cause a syntax error.\\

\noindent There are other identifiers called \textit{reserved identifiers} that
should not be used. They do not cause syntax errors as they are valid names. However,
the language already uses them or reserves the right to use them, so it could cause
problems if you use these identifiers to mean something else. An example of this
would be the name of standard library functions such as \textbf{printf}.

\begin{lstlisting}[title=Keywords in C, language=C]
  auto                                  short
  break                                 signed
  case                                  sizeof
  char                                  static	
  const                                 struct
  continue                              switch
  default                               typedef
  do                                    union
  double                                unsigned
  else                                  void
  enum                                  volatile
  extern                                while
  float                                 _Alignas
  for                                   _Alignof
  goto                                  _Bool
  if                                    _Complex
  inline                                _Generic
  int                                   _Imaginary
  long                                  _Noreturn
  register                              _Static_assert
  restrict                              #_Thread_local
  return
\end{lstlisting}

\chapter{Data Types}

\section{Data types overview}
The table below shows the data types that are available in C today
\begin{lstlisting}[title=C data keywords, language=C]
  
  // Original keywords in C as per K&R
    char
    double
    float
    int
    long
    short
    unsigned
  
  // Keywords added in C90
    signed
    void
  
  // C99 keywords
    _Bool
    _Complex
    _Imaginary
  
\end{lstlisting}

\section{Int}
The \textbf{int} type is a signed integer, which means that it can be
positive, negative or zero. It has the same size as the word size of the
machine it is being used on. Although most compilers implement int as 32-bit
even on 64-bit machines. For \textbf{Octal} we can prefix the number with 0
and for \textbf{Hexadecimal} we can prefix 0X or 0x. The behavior of int can
be changed by using the following

\begin{itemize}
\itemsep-3pt
\item \textbf{short} : This is used when we need less storage than an int
\item \textbf{long} : This is used when we need more storage than an int
\item \textbf{unsigned} : This is used when we only need positive values
\end{itemize}

\noindent The most common practice today on personal computers is to set up
\textbf{long long} as 64 bits, \textbf{long} as 32 bits, \textbf{short} as 16 bits,
and \textbf{int} as either 16 bits or 32 bits, depending on the machine's natural
word size.

\section{Char}
The char type is used for storing characters such as letters and punctuation marks,
but technically it is an integer type. The \textbf{char} type stores integers and 
not characters. To handle characters C uses ASCII. Each character is defined as an
8-bit unit of memory.\\

\noindent Characters can be initialized by including a single character between
single quotes. Non-printing characters can be printed by using escape characters

\begin{lstlisting}[language=C, title=Escape sequences]

  \a         // Alert(ANSI C)
  \b         // Backspace
  \f         // Form feed
  \n         // Newline
  \r         // Carriage return
  \t         // Horizontal Tab
  \v         // Vertical Tab
  \\         // Backslash
  \'         // Single quote
  \"         // Double quote
  \?         // Question mark
  \0oo       // Octal value (o represents an octal digit)
  \xhh       // Hexadecimal value (h represents a hexadecimal digit)
\end{lstlisting}

\section{Portable Types}
To ensure that the length of the int is exactly what we expect we can use the 
headers shown below

\begin{lstlisting}[language=C]
  #include <stdint.h>
  #include <inttypes.h>
  
  // The stdint defines the following types
    int8_t;         int_least8_t;           int_fast8_t;
    int16_t;              :                      :
    int32_t;              :                      :
    int64_t;              :                      :
    uint8_t;              :                      :
    uint16_t;             :                      :
    uint32_t;             :                      :
    uint64_t;       uint_least64_t;         uint_fast64_t;
\end{lstlisting}

\section{Floating point numbers}
These allow us to represent a wider range of numbers, including decimal fractions.
The \textbf{float} type allows us to represent at least six significant figures and
allows a range of at least $10^{-37}$ to $10^{37}$. The \textbf{double} type uses
the same minimum range requirements as float but allows more significant figures to
be used. This is done by storing the data in a bigger memory area. Similar to int
we can also use \textbf{long double}.

\section{Type Sizes}
To find out the size of a particular data type we use the \textbf{sizeof} operator.

\begin{lstlisting}[language=C]
  printf("Type int has a size of %zd bytes", sizeof(int));
\end{lstlisting}

\section{Printing using format specifiers}
\begin{lstlisting}[language=C, title=Print format specifiers]
  %c        // Character    char, unsigned char
  %d        // Signed Integer	short, unsigned short, int, long
  %e or %E  // Scientific notation of float values	float, double
  %f        // Floating point	float
  %g or %G  // Similar as %e or %E	float, double
  %hi       // Signed Integer(Short)	short
  %hu       // Unsigned Integer(Short)	unsigned short
  %i        // Signed Integer	short, unsigned short, int, long
  %l        // Signed Integer long
  %ld       // Signed Integer long
  %li       // Signed Integer long
  %lf       // Floating point	double
  %Lf       // Floating point	long double
  %lu       // Unsigned integer	unsigned int, unsigned long
  %lli      // Signed Integer	long long
  %lld      // Signed Integer	long long
  %llu      // Unsigned Integer	unsigned long long
  %o        // Octal representation of Integer.	 Same as %d
  %p        // Address of pointer to void void *	void *
  %s        // String	char *
  %u        // Unsigned Integer	unsigned int, unsigned long
  %x or %X  // Hexadecimal representation of Unsigned Integer	Same as %d
  %n        // Prints nothing	
  %%        // Prints % character
\end{lstlisting}

\chapter{Character Strings}
\section{String}
A character string is a series of one or more characters. It is enclosed by double quotes. This
is used to indicate to the C compiler that everything between the quotes is part of the string. C has
no special type for strings. Instead, \textbf{strings} are stored in array of type \textbf{char}.
Character strings are stored in contiguous memory locations. To mark the end of string C uses a
\textbf{\textbackslash0} character called the \textit{null character}.

\begin{lstlisting}[language=C]
  char name[6] = "Rahul";
\end{lstlisting}

\noindent As we see in the above example we defined an array of size 6 to hold a string of size 5 as we
also had to include space to store the null character. The null character is stored at the end of the string.
This means that for a string of size 50 if we are only storing a string of length 10 then the null character
is stored at position 11.

\section{String Length and sizeof}
To find the length of the string we can use the \textbf{strlen} function. This is included in the
\textbf{string.h} header file. This function will parse the string till it finds a null character and report
the length of the string. The operator \textbf{sizeof} reports the size of the variable. The example below
shows usage of both.

\begin{lstlisting}[language=C]
  char name[40] = "Rahul";
  printf("The length of your string is %zd\n", strlen(name));  // Returns 5
  printf("The occupied memory is %zd\n", sizeof name);              // Returns 40
\end{lstlisting}

\section{Constants}
Originally C used the idea of a preprocessor directive to define constants. This was done by using
\textbf{\#define}, which has the syntax as shown below

\begin{lstlisting}[language=C]
  #define <NAME_OF_DEFINITION> definition
  #define PI 3.14159
\end{lstlisting}

\noindent The disadvantage with this method is that we are not able to define constants with types and since
preprocessor directives are applied before the compilation. C has the \textbf{const} keyword that allows us
to declare constants based on types.

\begin{lstlisting}[language=C]
  const int months = 12; // Initialized at declaration
\end{lstlisting}

\section{I/O printf and scanf}
The \textbf{printf} statement is used to print to console in C. This operator is unique in that it takes a
variable length argument list. Hence, the number of arguments that are given to the printf statement can be
variable. The first argument contains the control string which is used by C to print out the data in the
format specified in the control string. For example 01001100 may be printed as 76, 4c or L based on whether
the control string has \%d, \%x or \%c.\\

\noindent The function printf also returns a value, it returns the number of characters that it printed. Although
this is not commonly used, it can be used to check for certain kinds of errors.\\ 

\noindent The \textbf{scanf} function is used to read input from the console and store them into variables. It
is similar in operation to the printf function discussed above except for one major change. The printf function
uses variable names, constants and expressions. The scanf function uses pointers instead of the actual variables.\\

\noindent The scanf function uses whitespaces (tabs, newlines and spaces) to decide how to divide the input into
separate fields. The only exception to this rule is the control string \%c which reads the next character without
regards to the whitespace rule.

\chapter{Operators}
\section{Arithmetic Operators}
C uses \textit{operators} to represent arithmetic operations. The operators supported by C
include the following

\begin{lstlisting}[language=C, title=Arithmetic operators]
  
  = // Assignment
  + // Addition
  - // Subtraction
  * // Multiplication
  / // Division
  % // Modulus
  ++ // Increment
  -- // Decrement
  sizeof // Determine the size of the operand
  
\end{lstlisting}

\section{Operator Precedence}
\noindent Each operator is assigned a \textbf{precedence} level. This determines which
operator needs to be evaluated first. If two operators have the same precedence and they 
also share an operand then they are executed in the order in which they appear in the
statement. For most operators, this is going to be \textit{left to right}.\\

\indent For arithmetic operators this is the precedence in decreasing precedence.

\begin{lstlisting}[language=C, title=Operator precedence]
  ( )    // Left to Right
  ++ --  // Left to Right
  + -    // (Unary) Right to Left
  * / %  // Left to Right
  + -    // Left to Right
  < > <= >= // Left to Right
  == !=  // Left to Right
  =      // Right to Left
\end{lstlisting}

\section{Expression}
\noindent An expression is a combination of operators and operands. The simplest expression
is just a operand (constant or variable). Every expression has a value, which can be found
by operating on the operands with the operator.

\section{Statements}
\noindent Statements are expressions with a semi-colon at the end. A program is technically
a series of statements with some necessary punctuation. A statement is a complete
instruction to the computer. A statement may or may not have a \textit{side effect}, which
is defined as the modification of a data object or file. Statements are of the following
types:

\begin{itemize}
  \itemsep-3pt
  \item Declaration
  \item Assignment
  \item Function Call
  \item Structured
  \item Return
  \item Null
\end{itemize}

\section{Type Conversions}
\noindent Whenever we mix types in C, it performs some type conversions automatically.
There are a set of rules that it follows to do the automatic type conversion

\begin{itemize}
  \itemsep-3pt
  \item For two distinct types, the lower type is converted to the higher type
  \item The length of data type determines who is higher and who is lower
  \item In assignment, conversion takes place towards the result
  \item In functions, char and short go to int and float to double
\end{itemize}

\noindent Sometimes to force type conversions we can explicitly cast a variable into
a different type based on our requirement. The syntax for doing the same is shown below

\begin{lstlisting}[language=C, title=Type conversion]
  int total;
  total = 1.4 + 1.6; // No casting, total will end up with 3
  total = (int) 1.4 + (int) 1.6 // Casting before addition, ends up with 2
\end{lstlisting}

\chapter{Control Statements}
\section{While Loop}
Looping allows us to perform an operation more than once upto a fixed number of times.
There are multiple ways to loop in C. The \textbf{while} loop is an entry condition loop
where the condition is tested before the loop is entered and if it is true then the 
subsequent statements in the while block are executed. These statements are executed till
the condition evaluates to false. 

\begin{lstlisting}[language=C, title=While loop]

  while( expression ) {
    // Statements to execute  
  }
\end{lstlisting}

\noindent In the above example, there is a check which is done to find out the
truth value before the iteration of the loop is performed again. In C we have a very
loose notion of truth. 0 is considered false and any non-zero value is considered
the truth. Another shorthand that is used to evaluate test conditions is you can 
directly specify the variable instead of checking if it is equal or not to zero.\\

\noindent C has introduced a new \textbf{\_Bool} type. This type can only have two
values which are True and False. If you try to assign a nonzero numeric value to a
\textbf{\_Bool} variable then it is stored as 1, while False is stored as 0.

\section{For Loop}
\noindent The \textbf{for} loop has three actions which are initializing, testing 
and then updating the condition in the beginning of the for loop. The initialize
expression is only executed once and it need not necessarily be an initialization
and could be a printf statement.\\

\noindent In the C and C++ programming languages, the comma operator (represented
by the token ,) is a binary operator that evaluates its first operand and discards
the result, and then evaluates the second operand and returns this value (and type).
This operator also guarantees that the expressions would be evaluated in a left to
right order, hence the side effect of one of the expressions could be used in the
expression on the right.\\

\noindent The comma operator is also used as a separator during variable initialization
and also in functions to separate the arguments to that function.

\begin{lstlisting}[language=C, title=For loop]

  for( initialize; test; update) {
    // Statements to execute  
  }
  
  for(;;) // valid for loop

  for( init1, init2; test ; update1, update2) {
    // Multiple initializations and updates
  }
\end{lstlisting}

\section{Do While Loop}
\noindent The \textbf{do while} loop is an exit condition loop, in which the exit
condition is checked after the iteration of the loop, this guarantees that the
loop will execute at least once.

\begin{lstlisting}[language=C, title=Do while loop]
  
  do {
    // Execute statements  
  } while (expression);
\end{lstlisting}

\section{Branching statements}
\noindent The \textbf{if} statement is a branching statement which allows us to 
conditionally execute a set of statements. If we want to take an alternative path
based on the if condition we can also include an \textbf{else} statement. The 
syntax for these is shown below. 

\begin{lstlisting}[language=C, title=Branching statements]
  
  if ( expression ) {
    // Statements to execute 
  } else {
    // Alternative statements to execute  
  }
\end{lstlisting}

\noindent The branching statements are often used with logical operators, these
include \textbf{OR}, \textbf{AND} and \textbf{NOT}. These are represented in C as
shown below. OR and AND take two operands and return \textbf{True} or \textbf{False}
based on the operands. The NOT operator takes a single operand.

\begin{lstlisting}[language=C]
  || // OR
  && // AND
  !  // NOT
\end{lstlisting}

\noindent C also has a \textbf{ternary} operator which takes three operands and is 
a shorthand for the if-else condition. It uses the token ? and has a general syntax
as shown below, which is saying if \textbf{expr1} then \textbf{expr2} else \textbf{expr3}

\begin{lstlisting}[language=C]
  expression1 ? expression2 : expression3
\end{lstlisting}

\section{Exiting Loops}
\noindent There are situations where we want to exit the loop or skip evaluation for
that iteration. C allows us to do that by using the \textbf{break} and \textbf{continue}
statements. These statements allow loops to be terminated or skipped respectively.\\

\noindent The \textbf{break} statement immediately stops the execution of the loop and 
continues after the last statement of the loop. In case of nested loops the break 
statement only breaks out of the loop in which it is called. The \textbf{continue}
statement on the other hand is used to skip the current iteration and goes to the 
first statement after the loop without going through the rest of the loop.

\section{Switch statement}
\noindent Sometimes a program needs to take multiple paths based on a condition. We can
use nested if else statements to do this but an easier, faster and more readable 
alternative is \textbf{switch}. This statement allows us to take one of the many 
branches based on a condition. The break statement at the end of each case is used to 
exit out of the switch otherwise the execution continues onto the next case.

\noindent There can be multiple labels with the same action. To do this we can define
all of them together and only write the common logic and the break statement in the last
instance of the case which are all grouped together.

\begin{lstlisting}[language=C, title=Switch statement]

  switch (expression) {
    case '1':
      // Statements here, ending with break
    case '2':
      // Statements here, ending with break  
    default:
      // Statements here
  }

\end{lstlisting}

\section{Goto Statement}
\noindent The \textbf{goto} statement is used to transfer control over to a named block
by calling the block name with the prefix goto. This is generally considered a bad 
practice as it makes it difficult to follow the order of execution. 

\begin{lstlisting}[language=C, title=Goto statement]

  if ( x > 10 )
    goto label;
  
  label: printf("This is something");
  
\end{lstlisting}

\chapter{Input/Output in C}

% The programming language Scala starts here
\part{Scala}
\setcounter{chapter}{0}
\chapter{Types in Scala}
\begin{itemize}
\itemsep-3pt
\item  Byte        8-bit signed two's complement integer (-27 to 27 - 1, inclusive)
\item  Short       16-bit signed two's complement integer (-215 to 215 - 1, inclusive)
\item Int         32-bit signed two's complement integer (-231 to 231 - 1, inclusive)        
\item Long        64-bit signed two's complement integer (-263 to 263 - 1, inclusive)
\item Char        16-bit unsigned Unicode character (0 to 216 - 1, inclusive)        
\item String        a sequence of Chars        
\item Float        32-bit IEEE 754 single-precision float
\item Double        64-bit IEEE 754 double-precision float        
\item Boolean        true or false
\end{itemize} 
\end{document}
